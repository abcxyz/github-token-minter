name: 'github-token-minter action'
description: 'Exchange a GitHub OIDC token for one with elevated privlidges.'

inputs:
  wif_provider:
    description: 'Workload identity federation provider.'
    required: true
  wif_service_account:
    description: 'Workload identity federation service account.'
    required: true
  service_audience:
    description: 'Cloud Run audience for the production github-token-minter service'
    required: true
  service_url:
    description: 'URL for the production github-token-minter service'
    required: true
  requested_permissions:
    description: 'Permission request information in the form {"repositories":["github-token-minter"],"permissions":{"issues":"read"}}'
    required: true

outputs:
  token:
    description: 'Newly minted token'
    value: '${{ steps.mint-token.outputs.token }}'

runs:
  using: 'composite'
  steps:
    - id: 'auth'
      name: 'Authenticate to Google Cloud'
      uses: 'google-github-actions/auth@71fee32a0bb7e97b4d33d548e7d957010649d8fa' # ratchet:google-github-actions/auth@v2
      with:
        create_credentials_file: false
        export_environment_variables: false
        workload_identity_provider: '${{ inputs.wif_provider }}'
        service_account: '${{ inputs.wif_service_account }}'
        token_format: 'id_token'
        id_token_audience: '${{ inputs.service_audience }}'
        id_token_include_email: true

    - id: 'mint-token'
      uses: 'actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea' # ratchet:actions/github-script@v7
      env:
        TOKEN: '${{ steps.auth.outputs.id_token }}'
        SERVICE_URL: '${{ inputs.service_url }}'
        REQUESTED_PERMISSIONS: '${{ inputs.requested_permissions }}'
      with:
        script: |
          try {
            core.warning('This GitHub action is being deprecated. Please migrate to github.com/abcxyz/github-token-minter/.github/actions/minty.')

            const { TOKEN, SERVICE_URL, REQUESTED_PERMISSIONS } = process.env;
            const idToken = await core.getIDToken('github-token-minter');
            const response = await fetch(`${SERVICE_URL}/token`, {
              method: 'post',
              body: REQUESTED_PERMISSIONS,
              headers: {
                'Content-Type': 'application/json',
                'X-OIDC-Token': idToken,
                'Authorization': `Bearer ${TOKEN}`,
              }
            });

            // get the response as text so we can try to parse JSON
            const responseText = await response.text();

            if (response.ok) {
              try {
                // Parse response as JSON
                // Format: { "ok": true, "result": "TOKEN" } (New)
                // Format: { "token": "TOKEN" } (Old)
                const resp = JSON.parse(responseText);
                if (resp.ok && resp.result) {
                   core.setOutput("token", resp.result);
                } else if (resp.token) {
                   core.setOutput("token", resp.token);
                } else {
                   // Fallback for unexpected JSON structure
                   core.warning("Parsed JSON response but did not find token or result field.");
                }
              } catch (err) {
                // Not JSON, assume response text is the token (Legacy-Legacy)
                const token = responseText;
                core.setOutput("token", token);
              }
            } else {
              // Handle Error Responses
              try {
                 const resp = JSON.parse(responseText);
                 if (resp.ok === false && resp.message) {
                    core.error(`Server Error [${resp.code || "UNKNOWN"}]: ${resp.message}`);
                 } else {
                    core.error(`Error response from server: ${responseText}`);
                 }
              } catch (e) {
                 core.error(`Error response from server: ${responseText}`);
              }
              throw new Error(`HTTP Error Response: ${response.status} ${response.statusText}`);
            }
          }
          catch (err) {
            core.setFailed(err);
          }
